

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Variational Shape Approximation (VSA) &mdash; Truchas 1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=fd3f3429" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/sphinxdoc.css" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/custom.css?v=453172ad" />

  
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=f2a433a1"></script>
      <script src="../../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="METIS patching (METIS)" href="metis.html" />
    <link rel="prev" title="Vertex Anchor Cluster Paving (PAVE)" href="pave.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            Truchas
              <img src="../../../_static/logo.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Radiation Enclosure Tools</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../index.html#contents">Contents</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="index.html">Enclosure Patches</a><ul class="current">
<li class="toctree-l4 current"><a class="reference internal" href="index.html#patch-algorithms">Patch Algorithms</a><ul class="current">
<li class="toctree-l5"><a class="reference internal" href="pave.html">Vertex Anchor Cluster Paving (PAVE)</a></li>
<li class="toctree-l5 current"><a class="current reference internal" href="#">Variational Shape Approximation (VSA)</a><ul>
<li class="toctree-l6"><a class="reference internal" href="#algorithm">Algorithm</a><ul>
<li class="toctree-l7"><a class="reference internal" href="#outline">Outline</a></li>
<li class="toctree-l7"><a class="reference internal" href="#error-minimization">Error Minimization</a><ul>
<li class="toctree-l8"><a class="reference internal" href="#l21-metric"><span class="math notranslate nohighlight">\(\mathcal{L}^{2,1}\)</span> metric</a></li>
<li class="toctree-l8"><a class="reference internal" href="#l2-metric"><span class="math notranslate nohighlight">\(\mathcal{L}^2\)</span> metric</a></li>
</ul>
</li>
<li class="toctree-l7"><a class="reference internal" href="#geometry-partitioning">Geometry Partitioning</a><ul>
<li class="toctree-l8"><a class="reference internal" href="#face-weight">Face Weight</a><ul>
<li class="toctree-l9"><a class="reference internal" href="#normal-bias">Normal Bias</a></li>
<li class="toctree-l9"><a class="reference internal" href="#distance-bias">Distance Bias</a></li>
<li class="toctree-l9"><a class="reference internal" href="#size-bias">Size Bias</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l7"><a class="reference internal" href="#proxy-fitting">Proxy Fitting</a></li>
</ul>
</li>
<li class="toctree-l6"><a class="reference internal" href="#namelist-parameters">Namelist Parameters</a><ul>
<li class="toctree-l7"><a class="reference internal" href="#vsa-max-iter">VSA_MAX_ITER</a></li>
<li class="toctree-l7"><a class="reference internal" href="#vsa-min-delta">VSA_MIN_DELTA</a></li>
<li class="toctree-l7"><a class="reference internal" href="#vsa-face-patch-ratio">VSA_FACE_PATCH_RATIO</a></li>
<li class="toctree-l7"><a class="reference internal" href="#vsa-max-patch-radius">VSA_MAX_PATCH_RADIUS</a></li>
<li class="toctree-l7"><a class="reference internal" href="#vsa-normalize-dist">VSA_NORMALIZE_DIST</a></li>
<li class="toctree-l7"><a class="reference internal" href="#vsa-random-seed">VSA_RANDOM_SEED</a></li>
</ul>
</li>
<li class="toctree-l6"><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="metis.html">METIS patching (METIS)</a></li>
<li class="toctree-l5"><a class="reference internal" href="vac.html">Vertex Anchor Cluster (VAC)</a></li>
<li class="toctree-l5"><a class="reference internal" href="index.html#general-guidance">General guidance</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="index.html#patches-namelist">PATCHES Namelist</a></li>
<li class="toctree-l4"><a class="reference internal" href="index.html#references">References</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Truchas</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Radiation Enclosure Tools</a></li>
          <li class="breadcrumb-item"><a href="index.html">Enclosure Patches</a></li>
      <li class="breadcrumb-item active">Variational Shape Approximation (VSA)</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../_sources/tools/RadE/patches/vsa.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="variational-shape-approximation-vsa">
<h1>Variational Shape Approximation (VSA)<a class="headerlink" href="#variational-shape-approximation-vsa" title="Link to this heading"></a></h1>
<figure class="align-center" id="id9" style="width: 50%">
<img alt="../../../_images/basic_hemi_vsa_2.png" src="../../../_images/basic_hemi_vsa_2.png" />
<figcaption>
<p><span class="caption-text">Result of VSA on a quarter cylinder.</span><a class="headerlink" href="#id9" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The Variational Shape Approximation (VSA) patching algorithm is based on the face clustering
algorithm presented by Cohen-Steiner et al. in their paper by the same name
<span id="id1">[<a class="reference internal" href="#id6" title="David Cohen-Steiner, Pierre Alliez, and Mathieu Desbrun. Variational Shape Approximation. In ACM SIGGRAPH 2004 Papers, SIGGRAPH '04, 905–914. New York, NY, USA, 2004. ACM. doi:10.1145/1186562.1015817.">1</a>]</span>. VSA is a modification of <a class="reference external" href="https://en.wikipedia.org/wiki/Lloyd%27s_algorithm">Lloyd’s algorithm</a> for approximating <a class="reference external" href="https://en.wikipedia.org/wiki/Centroidal_Voronoi_tessellation">centroidal Voronoi
tessellations</a>. Instead of
approximating compact regions of the plane, VSA attempts to minimize the total distortion or error
of all patches in the enclosure. VSA alternates between two phases of <em>geometry partitioning</em> and
<em>proxy fitting</em> to drive the total error down. The two phases are run iteratively until a
convergence criterion is met.</p>
<nav class="contents local" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#algorithm" id="id10">Algorithm</a></p>
<ul>
<li><p><a class="reference internal" href="#outline" id="id11">Outline</a></p></li>
<li><p><a class="reference internal" href="#error-minimization" id="id12">Error Minimization</a></p>
<ul>
<li><p><a class="reference internal" href="#l21-metric" id="id13"><span class="math notranslate nohighlight">\(\mathcal{L}^{2,1}\)</span> metric</a></p></li>
<li><p><a class="reference internal" href="#l2-metric" id="id14"><span class="math notranslate nohighlight">\(\mathcal{L}^2\)</span> metric</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#geometry-partitioning" id="id15">Geometry Partitioning</a></p>
<ul>
<li><p><a class="reference internal" href="#face-weight" id="id16">Face Weight</a></p>
<ul>
<li><p><a class="reference internal" href="#normal-bias" id="id17">Normal Bias</a></p></li>
<li><p><a class="reference internal" href="#distance-bias" id="id18">Distance Bias</a></p></li>
<li><p><a class="reference internal" href="#size-bias" id="id19">Size Bias</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#proxy-fitting" id="id20">Proxy Fitting</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#namelist-parameters" id="id21">Namelist Parameters</a></p>
<ul>
<li><p><a class="reference internal" href="#vsa-max-iter" id="id22">VSA_MAX_ITER</a></p></li>
<li><p><a class="reference internal" href="#vsa-min-delta" id="id23">VSA_MIN_DELTA</a></p></li>
<li><p><a class="reference internal" href="#vsa-face-patch-ratio" id="id24">VSA_FACE_PATCH_RATIO</a></p></li>
<li><p><a class="reference internal" href="#vsa-max-patch-radius" id="id25">VSA_MAX_PATCH_RADIUS</a></p></li>
<li><p><a class="reference internal" href="#vsa-normalize-dist" id="id26">VSA_NORMALIZE_DIST</a></p></li>
<li><p><a class="reference internal" href="#vsa-random-seed" id="id27">VSA_RANDOM_SEED</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#references" id="id28">References</a></p></li>
</ul>
</nav>
<section id="algorithm">
<h2>Algorithm<a class="headerlink" href="#algorithm" title="Link to this heading"></a></h2>
<p>The VSA algorithm continuously alternates between two phases of <em>geometry partitioning</em> and <em>proxy
fitting</em> until a convergence criterion is met. Each phase attempts to reduce the total distortion
across all patches. Once the algorithm converges, we have found a patch configuration that minimizes
the total error.</p>
<p>The <em>geometry partitioning</em> phase starts from a set of <span class="math notranslate nohighlight">\(k\)</span> <em>seed patches</em>. These seed patches are
grown by adding adjacent faces with the least distortion to the patch. At the end of this phase,
every face is assigned to a patch, so the enclosure has been partitioned into <span class="math notranslate nohighlight">\(k\)</span> non-overlapping
connected regions (the patches).</p>
<p>Once a partition is found, the <em>proxy fitting</em> phase computes an ‘optimal representative’ of each
patch, called the patch proxy. These patch proxies correspond to the centroids of Lloyd’s algorithm
<span id="id2">[<a class="reference internal" href="#id6" title="David Cohen-Steiner, Pierre Alliez, and Mathieu Desbrun. Variational Shape Approximation. In ACM SIGGRAPH 2004 Papers, SIGGRAPH '04, 905–914. New York, NY, USA, 2004. ACM. doi:10.1145/1186562.1015817.">1</a>]</span>. In the partition phase, the face distortion is measured relative
to these proxies. At the end of the proxy fitting phase, the face with least distortion relative to
the new proxy is selected as a seed patch for the next iteration.</p>
<p>The seed patches for the first iteration are chosen with a ‘farthest-point’ initialization method.
To start, a random seed is chosen in each connected component of the enclosure. Then, seed patches
are added one at a time by performing a partitioning and then choosing the face with highest total
distortion as the new seed patch.</p>
<p>VSA also sparingly performs a ‘patch teleportation’ operation which moves a patch from a region with
low distortion to one with high distortion. These operations help reduce total distortion by moving
patches to where they are needed most.</p>
<section id="outline">
<h3>Outline<a class="headerlink" href="#outline" title="Link to this heading"></a></h3>
<ol class="arabic">
<li><p><strong>Initialization</strong></p>
<ol class="arabic simple">
<li><p>Compute the area, centroid, radius, and normal of each face.</p>
<ol class="arabic simple">
<li><p>The radius of a face is the radius of the smallest circle, centered at the centroid,
that encloses the whole face. Thus the radius is the largest distance between the centroid
and any of the face vertices.</p></li>
</ol>
</li>
<li><p>Generate the face adjacency matrix. Faces at angles greater than
<a class="reference internal" href="patches_namelist.html#max-angle"><span class="std std-ref">MAX_ANGLE</span></a> are not adjacent.</p></li>
<li><p>Let NPATCH_MIN = NFACE / VSA_FACE_PATCH_RATIO, where NFACE is the total number of faces
in the enclosure.</p></li>
<li><p>Let NPATCH=0. This variable tracks the current number of patches.</p></li>
<li><p>If provided, use <a class="reference internal" href="#vsa-random-seed"><span class="std std-ref">VSA_RANDOM_SEED</span></a> to initialize the
random number generator. Otherwise, take the seed from the system clock.</p></li>
</ol>
</li>
<li><p><strong>Pick initial seeds</strong></p>
<ol class="arabic simple">
<li><p>Let <span class="math notranslate nohighlight">\(G\)</span> be the face adjacency graph of the enclosure defined by the face adjacency matrix. For
each connected component of <span class="math notranslate nohighlight">\(G\)</span>, choose a random face in the component and make it a new seed
patch.</p></li>
<li><p>While NPATCH &lt; NPATCH_MIN:</p>
<ol class="arabic simple">
<li><p>Call PARTITION()</p></li>
<li><p>Reset all patches to their seed faces.</p></li>
<li><p>Create a new seed at the face with the highest weight (distortion).</p></li>
</ol>
</li>
</ol>
</li>
<li><p><strong>Error minimization</strong></p>
<ol class="arabic">
<li><p>Let <span class="math notranslate nohighlight">\(t\)</span> be the current iteration number and set <span class="math notranslate nohighlight">\(t=1\)</span>.</p></li>
<li><p>While <span class="math notranslate nohighlight">\(t\)</span> &lt;= VSA_MAX_ITER and ITER_DELTA &gt; VSA_MIN_DELTA:</p>
<ol class="arabic">
<li><p><strong>Pick Seeds</strong></p>
<ol class="arabic simple">
<li><p>For each patch <span class="math notranslate nohighlight">\(P_i\)</span> of the previous partition, find the face <span class="math notranslate nohighlight">\(F_k\)</span> with least
weight relative to <span class="math notranslate nohighlight">\(P_i\)</span>’s proxy <span class="math notranslate nohighlight">\(\rho_i = (X_i, \vec{n}_i)\)</span>, where <span class="math notranslate nohighlight">\(X_i\)</span> and
<span class="math notranslate nohighlight">\(\vec{n}_i\)</span> are the centroid and unit normal of <span class="math notranslate nohighlight">\(P_i\)</span>, respectively.</p></li>
</ol>
</li>
<li><p><strong>Geometry partitioning</strong></p>
<ol class="arabic simple">
<li><p>Call PARTITION()</p></li>
</ol>
</li>
<li><p><strong>Teleport patches</strong></p>
<ol class="arabic simple">
<li><p>If <span class="math notranslate nohighlight">\(t \bmod 5 \equiv 0\)</span>, call PATCH_DELETE() followed by PATCH_INSERT(). This
effectively ‘teleports’ a patch with low distortion to a region with high distortion.</p></li>
</ol>
</li>
<li><p><strong>Proxy fitting</strong></p>
<ol class="arabic">
<li><p>For each patch <span class="math notranslate nohighlight">\(P_i\)</span> with proxy <span class="math notranslate nohighlight">\(\rho_i^t = (X_i^t,\vec{n}_i^t)\)</span>, compute their new
proxy <span class="math notranslate nohighlight">\(\rho_i^{t+1}=(X_i^{t+1},\vec{n}_i^{t+1})\)</span>. Compute the change <span class="math notranslate nohighlight">\(\delta_i\)</span> between
the old and new proxies:</p>
<div class="math notranslate nohighlight">
\[\delta_i = \lVert X_i^{t+1} - X_i^t \rVert^2 + \lVert \vec{n}_i^{t+1} - \vec{n}_i^t \rVert^2\]</div>
</li>
<li><p>Let ITER_DELTA be the minimum change <span class="math notranslate nohighlight">\(\delta_i\)</span> between the old and new proxies across
all patches.</p></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<ul>
<li><p><strong>Subroutines</strong></p>
<ul>
<li><p>PARTITION()</p>
<ol class="arabic simple">
<li><p>For each seed face <span class="math notranslate nohighlight">\(F_i\)</span> of a patch <span class="math notranslate nohighlight">\(P_i\)</span> with proxy <span class="math notranslate nohighlight">\(\rho_i\)</span>, insert the each face <span class="math notranslate nohighlight">\(F_n\)</span>
adjacent to <span class="math notranslate nohighlight">\(F_k\)</span> into a global priority queue with weight <span class="math notranslate nohighlight">\(E(F_n, \rho_i)\)</span>. The queue entry
includes a tag <span class="math notranslate nohighlight">\(i\)</span> denoting the proxy they are being compared against.</p></li>
<li><p>While the priority queue is not empty:</p>
<ol class="arabic simple">
<li><p>Pop the face <span class="math notranslate nohighlight">\(F_k\)</span> with least weight from the queue. If it’s already assigned to
a patch, continue. If not, assign <span class="math notranslate nohighlight">\(F_k\)</span> to the patch indicated by the tag and add
each unassigned face <span class="math notranslate nohighlight">\(F_n\)</span> adjacent to <span class="math notranslate nohighlight">\(F_k\)</span> to the queue with the same tag as <span class="math notranslate nohighlight">\(F_k\)</span>.</p></li>
</ol>
</li>
</ol>
</li>
<li><p>PATCH_DELETE()</p>
<ol class="arabic">
<li><p>For each pair of adjacent patches <span class="math notranslate nohighlight">\(P_i\)</span> and <span class="math notranslate nohighlight">\(P_j\)</span> with respective proxies
<span class="math notranslate nohighlight">\(\rho_i=(X_i,\vec{n}_i)\)</span> and <span class="math notranslate nohighlight">\(\rho_j=(X_j,\vec{n}_j)\)</span>, compute the proxy
<span class="math notranslate nohighlight">\(\rho_T=(X_T,\vec{n}_T)\)</span> of the patch <span class="math notranslate nohighlight">\(P_T = P_i \cap P_j\)</span> resulting from merging the two
patches. Compute the change between <span class="math notranslate nohighlight">\(\rho_T\)</span> and the original proxies as</p>
<div class="math notranslate nohighlight">
\[\delta_T = \lVert X_T - X_i \rVert^2 + \lVert \vec{n}_T - \vec{n}_i \rVert^2
         + \lVert X_T - X_j \rVert^2 + \lVert \vec{n}_T - \vec{n}_j \rVert^2\]</div>
<p>Keep track of of the pair of patches with minimal <span class="math notranslate nohighlight">\(\delta_T\)</span>.</p>
</li>
<li><p>Delete the pair of patches <span class="math notranslate nohighlight">\(P_i\)</span> and <span class="math notranslate nohighlight">\(P_j\)</span> with minimal <span class="math notranslate nohighlight">\(\delta_T\)</span>, and insert a new patch
<span class="math notranslate nohighlight">\(P_T = P_i \cap P_j\)</span> with the appropriate proxy <span class="math notranslate nohighlight">\(\rho_T\)</span>.</p></li>
</ol>
</li>
<li><p>PATCH_INSERT()</p>
<ol class="arabic simple">
<li><p>Find the face <span class="math notranslate nohighlight">\(F_k\)</span> with the highest weight relative to the proxy of its patch <span class="math notranslate nohighlight">\(P_i\)</span>. Remove
<span class="math notranslate nohighlight">\(F_k\)</span> from <span class="math notranslate nohighlight">\(P_i\)</span> and insert a new one-face patch at face <span class="math notranslate nohighlight">\(F_k\)</span>. Note that since patches with
one face have a weight of 0, <span class="math notranslate nohighlight">\(P_i\)</span> must have at least two faces.</p></li>
</ol>
</li>
</ul>
</li>
</ul>
</section>
<section id="error-minimization">
<h3>Error Minimization<a class="headerlink" href="#error-minimization" title="Link to this heading"></a></h3>
<p>Given a partition of a mesh into a collection of patches <span class="math notranslate nohighlight">\(\mathcal{R}\)</span> and the corresponding
collection of patch proxies <span class="math notranslate nohighlight">\(\mathcal{P}\)</span>, the VSA algorithm attempts to minimize the total
distortion error <span class="math notranslate nohighlight">\(E(\mathcal{R}, \mathcal{P})\)</span>.</p>
<p>The partitioning phase finds the set of patches <span class="math notranslate nohighlight">\(\mathcal{R}\)</span> with minimal error relative to the
proxies <span class="math notranslate nohighlight">\(\mathcal{P}\)</span>. Similarly, the proxy fitting phase computes the proxies <span class="math notranslate nohighlight">\(\mathcal{P}\)</span> that
minimize the distortion of each patch in the new partition <span class="math notranslate nohighlight">\(\mathcal{R}\)</span>. By alternating these
stages, VSA drives down the total distortion error <span class="math notranslate nohighlight">\(E(\mathcal{R}, \mathcal{P})\)</span>.</p>
<p>The error functional <span class="math notranslate nohighlight">\(E(\mathcal{R}, \mathcal{P})\)</span> of a mesh with <span class="math notranslate nohighlight">\(k\)</span> patches is given by:</p>
<div class="math notranslate nohighlight">
\[E(\mathcal{R}, \mathcal{P})
= \sum_{i=1 .. k} E(P_i, \rho_i)\]</div>
<p>where <span class="math notranslate nohighlight">\(P_i \in \mathcal{R}\)</span> is a patch with corresponding proxy <span class="math notranslate nohighlight">\(\rho_i \in \mathcal{P}\)</span>. The proxy
<span class="math notranslate nohighlight">\(\rho_i = (X_i, \vec{n}_i)\)</span> <em>represents</em> the patch <span class="math notranslate nohighlight">\(P_i\)</span> with the coordinate <span class="math notranslate nohighlight">\(X_i\)</span> and normal vector
<span class="math notranslate nohighlight">\(\vec{n}_i\)</span>. The distortion error <span class="math notranslate nohighlight">\(E(P_i, \rho_i)\)</span> of a patch-proxy pair is in turn given by:</p>
<div class="math notranslate nohighlight">
\[E(P_i, \rho_i) = \mathcal{L}^{2,1}(P_i, \rho_i) + \mathcal{L}^2(P_i, \rho_i)\]</div>
<p>The terms of <span class="math notranslate nohighlight">\(E(P_i, \rho_i)\)</span> are defined below.</p>
<section id="l21-metric">
<h4><span class="math notranslate nohighlight">\(\mathcal{L}^{2,1}\)</span> metric<a class="headerlink" href="#l21-metric" title="Link to this heading"></a></h4>
<p>Cohen-Steiner et al. <span id="id3">[<a class="reference internal" href="#id6" title="David Cohen-Steiner, Pierre Alliez, and Mathieu Desbrun. Variational Shape Approximation. In ACM SIGGRAPH 2004 Papers, SIGGRAPH '04, 905–914. New York, NY, USA, 2004. ACM. doi:10.1145/1186562.1015817.">1</a>]</span> define the so-called <span class="math notranslate nohighlight">\(\mathcal{L}^{2,1}\)</span> metric to measure
the planarity of a patch. The <span class="math notranslate nohighlight">\(\mathcal{L}^{2,1}\)</span> metric is based on an <span class="math notranslate nohighlight">\(\mathcal{L}^2\)</span> measure of the normal field over the
patch. Given a patch <span class="math notranslate nohighlight">\(P_i\)</span> and proxy <span class="math notranslate nohighlight">\(\rho_i = (X_i, \vec{n}_i)\)</span> we define</p>
<div class="math notranslate nohighlight">
\[\mathcal{L}^{2,1}(P_i) = \iint\limits_{x \in P_i} \lVert \vec{n}(x)  - \vec{n}_i \rVert^2 \,dx\]</div>
<p>where <span class="math notranslate nohighlight">\(\vec{n}(x)\)</span> is the normal at the point <span class="math notranslate nohighlight">\(x \in P_i\)</span>.</p>
</section>
<section id="l2-metric">
<h4><span class="math notranslate nohighlight">\(\mathcal{L}^2\)</span> metric<a class="headerlink" href="#l2-metric" title="Link to this heading"></a></h4>
<p>To measure the compactness of a patch, we use a simple Euclidean distance or <span class="math notranslate nohighlight">\(\mathcal{L}^2\)</span> metric. Given a
patch <span class="math notranslate nohighlight">\(P_i\)</span> with centroid <span class="math notranslate nohighlight">\(X_i\)</span> we define</p>
<div class="math notranslate nohighlight">
\[\mathcal{L}^2(P_i) = \iint\limits_{x \in P_i} \lVert x  - X_i \rVert^2 \,dx\]</div>
<p>Note that this is the same metric used by Lloyd’s algorithm to generate centroidal Voronoi
tessellations.</p>
</section>
</section>
<section id="geometry-partitioning">
<h3>Geometry Partitioning<a class="headerlink" href="#geometry-partitioning" title="Link to this heading"></a></h3>
<p>The partitioning phase ‘grows’ a collection of seed faces into connected patches by successively
adding adjacent faces to a patch. In order to construct a partition that minimizes total distortion,
we cluster faces that are ‘close together’ in the error metric <span class="math notranslate nohighlight">\(E(P_i, \rho_i)\)</span>.</p>
<p>Thus, for each patch <span class="math notranslate nohighlight">\(P_i\)</span> with proxy <span class="math notranslate nohighlight">\(/rho_i\)</span> and seed face <span class="math notranslate nohighlight">\(F_k\)</span>, we add each face <span class="math notranslate nohighlight">\(F_n\)</span> adjacent
to <span class="math notranslate nohighlight">\(F_k\)</span> to a global priority queue with an weight equal to their distortion error <span class="math notranslate nohighlight">\(E(F_n ,\rho_i)\)</span>
relative to the proxy.</p>
<p>The partitioning phase then proceeds by repeatedly popping the lowest weight face <span class="math notranslate nohighlight">\(F_k\)</span> until the
queue is empty. If the popped face was already assigned, we simply skip to the next face.
Otherwise, we assign each popped face to the patch indicated by the tag <span class="math notranslate nohighlight">\(i\)</span>. We then add all the
unassigned face neighbors <span class="math notranslate nohighlight">\(F_n\)</span> of <span class="math notranslate nohighlight">\(F_k\)</span> to the queue, with weight <span class="math notranslate nohighlight">\(E(F_n, \rho_i)\)</span> and tag <span class="math notranslate nohighlight">\(i\)</span>.
Once the queue is emptied, every face has been assigned to a patch and we have a new partition
<span class="math notranslate nohighlight">\(\mathcal{R}\)</span> of the mesh.</p>
<p>Note that each face can only be added to the queue once by each of its neighbors. Since the mesh is
assumed to be a manifold, each face can only as many neighbors as its number of edges. Thus, since
we are only working with triangular or quadrilateral meshes, each face can be queued at most 4
times. Note also that the partitioning phase runs in time <span class="math notranslate nohighlight">\(N\log(N)\)</span>
<span id="id4">[<a class="reference internal" href="#id6" title="David Cohen-Steiner, Pierre Alliez, and Mathieu Desbrun. Variational Shape Approximation. In ACM SIGGRAPH 2004 Papers, SIGGRAPH '04, 905–914. New York, NY, USA, 2004. ACM. doi:10.1145/1186562.1015817.">1</a>]</span>. Therefore, VSA is able to perform partitions very quickly,
reducing overall computation time.</p>
<section id="face-weight">
<h4>Face Weight<a class="headerlink" href="#face-weight" title="Link to this heading"></a></h4>
<p>Each entry of the global priority queue has an associated weight which determines their order in the
queue. The VSA queue prioritizes entries with a lower weight, so the faces with least distortion
relative to a patch will get added to that patch first.</p>
<p>Let the tuple <span class="math notranslate nohighlight">\((F_k, \rho_i)\)</span> denote the queue entry that tests face <span class="math notranslate nohighlight">\(F_k\)</span> against the patch proxy
<span class="math notranslate nohighlight">\(\rho_i=(X_i, \vec{n}_i)\)</span> of patch <span class="math notranslate nohighlight">\(P_i\)</span>, where <span class="math notranslate nohighlight">\(X_i\)</span> and <span class="math notranslate nohighlight">\(\vec{n}_i\)</span> are respectively the centroid
and unit normal of <span class="math notranslate nohighlight">\(P_i\)</span>. The weight <span class="math notranslate nohighlight">\(E\)</span> of a queue entry <span class="math notranslate nohighlight">\((F_k, \rho_i)\)</span> is given by the error
metric:</p>
<div class="math notranslate nohighlight">
\[E(F_k, \rho_i) = E_{normal}(F_k, \rho_i) + E_{dist}(F_k, \rho_i) + E_{size}(F_k, \rho_i)\]</div>
<p>The terms of <span class="math notranslate nohighlight">\(E(F_k, \rho_i)\)</span> are discussed below.</p>
<section id="normal-bias">
<h5>Normal Bias<a class="headerlink" href="#normal-bias" title="Link to this heading"></a></h5>
<p>We define the <em>normal bias</em> of a face <span class="math notranslate nohighlight">\(F_k\)</span> relative to a patch <span class="math notranslate nohighlight">\(P_i\)</span> with proxy <span class="math notranslate nohighlight">\(\rho_i=(X_i,
\vec{n}_i)\)</span> as the <span class="math notranslate nohighlight">\(\mathcal{L}^{2,1}\)</span> metric of the face normal <span class="math notranslate nohighlight">\(\vec{n}_k\)</span> relative to the proxy normal
<span class="math notranslate nohighlight">\(\vec{n}_i\)</span>:</p>
<div class="math notranslate nohighlight">
\[E_{normal}(F_k, \rho_i) = \lVert \vec{n}_k - \vec{n}_i \rVert^2\]</div>
<p>Since the largest deviation between the proxy normal <span class="math notranslate nohighlight">\(\vec{n}_i\)</span> and a face normal <span class="math notranslate nohighlight">\(\vec{n}_k\)</span> is
when these vectors are <a class="reference external" href="https://en.wikipedia.org/wiki/Antiparallel_(mathematics)#Antiparallel_vectors">antiparallel</a> it follows that <span class="math notranslate nohighlight">\(0
\le E_{normal}(F_k, \rho_i) \le 4\)</span> for any tuple <span class="math notranslate nohighlight">\((F_k, \rho_i)\)</span>.</p>
</section>
<section id="distance-bias">
<h5>Distance Bias<a class="headerlink" href="#distance-bias" title="Link to this heading"></a></h5>
<p>We define the <em>distance bias</em> of a face <span class="math notranslate nohighlight">\(F_k\)</span> relative to a patch <span class="math notranslate nohighlight">\(P_i\)</span> with proxy <span class="math notranslate nohighlight">\(\rho_i=(X_i,
\vec{n}_i)\)</span> as the square of the <span class="math notranslate nohighlight">\(\mathcal{L}^2\)</span> distance between the face centroid <span class="math notranslate nohighlight">\(X_k\)</span> and the proxy centroid
<span class="math notranslate nohighlight">\(X_i\)</span>, normalized by the face radius <span class="math notranslate nohighlight">\(r_k\)</span>.</p>
<div class="math notranslate nohighlight">
\[\begin{split}E_{dist}(F_k, \rho_i) =
\begin{cases}
   \left(\lVert X_k - X_i \rVert^2 + r_k^2\right) /\ r_k^2 &amp; \text{if distance normalization is enabled} \\
   \lVert X_k - X_i \rVert^2 + r_k^2 &amp; \text{otherwise}
\end{cases} \\\end{split}\]</div>
<p>The <a class="reference internal" href="#vsa-normalize-dist"><span class="std std-ref">VSA_NORMALIZE_DIST</span></a> parameter controls whether the distance is
normalized by the face radius <span class="math notranslate nohighlight">\(r_k\)</span>. With normalization, <span class="math notranslate nohighlight">\(E_{dist}\)</span> roughly measures how many “faces
away” the patch center is (assuming the surrounding faces are of similar size). Therefore, enabling
normalization tends to produce patches wit a similar number of faces, regardless of the physical
size of each patch. Conversely, disabling normalization tends to make all patches about the same
physical size, regardless of the number of faces in each patch.</p>
<p>Normalization is enabled by default. This makes <span class="math notranslate nohighlight">\(E_{dist}\)</span> less dependent on the size of the face.
Without normalization, larger faces tend to have a larger weight than smaller faces since their
centroids are further from the nodes of the face. In particular, this causes large faces to get
preferentially selected as initial seeds, resulting in components covered with one face patches.</p>
</section>
<section id="size-bias">
<h5>Size Bias<a class="headerlink" href="#size-bias" title="Link to this heading"></a></h5>
<p>We define the <em>size bias</em> of a face <span class="math notranslate nohighlight">\(F_k\)</span> relative to a patch <span class="math notranslate nohighlight">\(P_i\)</span> with proxy <span class="math notranslate nohighlight">\(\rho_i=(X_i,
\vec{n}_i)\)</span> as</p>
<div class="math notranslate nohighlight">
\[\begin{split}E_{size}(F_k, \rho_i) =
\begin{cases}
   0 &amp; \text{if } \lVert X_k - X_i \rVert \le r_{max} \\
   100 * \lVert X_k - X_i \rVert^2\ /\ r_{max}^2  &amp; \text{otherwise}
\end{cases} \\\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(r_k\)</span> is the face radius and <span class="math notranslate nohighlight">\(r_{max}\)</span> is the maximum patch radius defined by the
<a class="reference internal" href="#vsa-max-patch-radius"><span class="std std-ref">VSA_MAX_PATCH_RADIUS</span></a> parameter. The size bias heavily penalizes faces
that are outside the maximum patch radius. This discourages the formation of patches that are
significantly larger than the specified radius. We use this “strong suggestion” approach because
outright preventing faces from being added to a patch might result in faces with no patch assignment.</p>
<p>By default, <span class="math notranslate nohighlight">\(r_{max}\)</span> is set to a very large positive real number. Thus, the size bias has no effect
unless it is explicitly set to a value comparable to the mesh size.</p>
</section>
</section>
</section>
<section id="proxy-fitting">
<h3>Proxy Fitting<a class="headerlink" href="#proxy-fitting" title="Link to this heading"></a></h3>
<p>Each patch <span class="math notranslate nohighlight">\(P_i\)</span> has an associated proxy <span class="math notranslate nohighlight">\(\rho_i = (X_i, \vec{n}_i)\)</span> that represents the patch with
two quantities, namely the coordinate <span class="math notranslate nohighlight">\(X_i\)</span> and the normal vector <span class="math notranslate nohighlight">\(\vec{n}_i\)</span>.</p>
<p>Once a partition of the enclosure <span class="math notranslate nohighlight">\(\mathcal{R}\)</span> is found, we wish to update the patch proxies to
minimize the distortion error</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align*}
  E(P_i, \rho_i)
  &amp;= \mathcal{L}^{2,1}(P_i, \rho_i) + \mathcal{L}^2(P_i, \rho_i) \\
  &amp;= \iint\limits_{x \in P_i} \lVert \vec{n}(x)  - \vec{n}_i \rVert^2 \,dx
   + \iint\limits_{x \in P_i} \lVert x  - X_i \rVert^2 \,dx
\end{align*}\end{split}\]</div>
<p>of each patch. It can be shown that the choice of proxy that minimizes <span class="math notranslate nohighlight">\(E(P_i, \rho_i)\)</span> is when
<span class="math notranslate nohighlight">\(X_i\)</span> is the centroid of the patch and <span class="math notranslate nohighlight">\(\vec{n}_i\)</span> is the average normal over the patch. Thus, we
compute the new proxy <span class="math notranslate nohighlight">\(\rho_i=(X_i, \vec{n}_i)\)</span> as the area-weighted average of the face centroids
and face normals</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align*}
  X_i       &amp;= \frac{\sum_{F_k \in P_i} w_k \cdot X_k}{W_i} \\
  \vec{n}_i &amp;= \frac{\sum_{F_k \in P_i} w_k \cdot \vec{n}_k}{W_i}
\end{align*}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(X_k\)</span>, <span class="math notranslate nohighlight">\(\vec{n}_k\)</span>, and <span class="math notranslate nohighlight">\(w_k\)</span> are respectively the centroid, unit normal, and area of <span class="math notranslate nohighlight">\(F_k\)</span>,
and <span class="math notranslate nohighlight">\(W_i = \sum_{F_k \in P_i} w_k\)</span> is the area of <span class="math notranslate nohighlight">\(P_i\)</span>.</p>
<p>By choosing proxies that minimize the distortion error of each patch, VSA reduces the total error
<span class="math notranslate nohighlight">\(E(\mathcal{R}, \mathcal{P})\)</span>.</p>
</section>
</section>
<section id="namelist-parameters">
<h2>Namelist Parameters<a class="headerlink" href="#namelist-parameters" title="Link to this heading"></a></h2>
<p>The <a class="reference internal" href="patches_namelist.html"><span class="doc">PATCHES namelist</span></a> allows a user to configure the VSA algorithm
parameters. Although the PATCHES namelist supports many parameters, only eight are used by VSA, and
only six of those are unique to VSA.</p>
<p>The general parameters used by VSA are VERBOSITY_LEVEL and MAX_ANGLE. Refer to the <a class="reference internal" href="patches_namelist.html#general-parameters"><span class="std std-ref">PATCHES
namelist documentation</span></a> for more
information on those parameters.</p>
<p>The six parameters unique to VSA are all prefixed with <em>VSA</em>. We discuss these parameters
briefly below.</p>
<section id="vsa-max-iter">
<h3>VSA_MAX_ITER<a class="headerlink" href="#vsa-max-iter" title="Link to this heading"></a></h3>
<p>Defines the maximum number of iterations for the <a class="reference internal" href="#outline"><span class="std std-ref">error minimization</span></a> step of the algorithm.</p>
<blockquote class="nml-param">
<div><p><strong>Type:</strong> <code class="docutils literal notranslate"><span class="pre">INTEGER</span></code></p>
<p><strong>Domain:</strong> vsa_max_iter &gt;= 1</p>
<p><strong>Default:</strong> vsa_max_iter = 1000</p>
</div></blockquote>
<p>The algorithm stops when <code class="docutils literal notranslate"><span class="pre">vsa_max_iter</span></code> is reached, regardless of other
terminating conditions.</p>
</section>
<section id="vsa-min-delta">
<h3>VSA_MIN_DELTA<a class="headerlink" href="#vsa-min-delta" title="Link to this heading"></a></h3>
<p>Defines the minimum allowable change in patch proxies between successive iterations.</p>
<blockquote class="nml-param">
<div><p><strong>Type:</strong> <code class="docutils literal notranslate"><span class="pre">REAL</span></code></p>
<p><strong>Domain:</strong> vsa_min_delta &gt;= 0.0</p>
<p><strong>Default:</strong> vsa_min_delta = 1.0E-6</p>
</div></blockquote>
<p>At the end of each iteration, the new patch proxies for the next iteration are computed and compared
against the old proxies. VSA keeps track of the <em>minimum</em> change between the old and new proxies.
This change is computed as the sum of the squares of the difference between the old and new proxy
vectors. If the minimum change in patch proxies is less than <code class="docutils literal notranslate"><span class="pre">vsa_min_delta</span></code>, the algorithm is
said to converge and will terminate at that iteration.</p>
<p>For more details on how the change between old and new proxies is computed, refer to step 3.2.4 of
the <a class="reference internal" href="#outline"><span class="std std-ref">algorithm outline</span></a>.</p>
</section>
<section id="vsa-face-patch-ratio">
<h3>VSA_FACE_PATCH_RATIO<a class="headerlink" href="#vsa-face-patch-ratio" title="Link to this heading"></a></h3>
<p>Defines the ratio of total faces to total patches, and by extension the total number of patches.</p>
<blockquote class="nml-param">
<div><p><strong>Type:</strong> <code class="docutils literal notranslate"><span class="pre">REAL</span></code></p>
<p><strong>Domain:</strong> vsa_face_patch_ratio &gt;= 1.0</p>
<p><strong>Default:</strong> vsa_face_patch_ratio = 4.0</p>
</div></blockquote>
<p>Since the number of faces is fixed, this parameter determines the total number of patches in the
final configuration:</p>
<div class="math notranslate nohighlight">
\[\text{(Total Patches)} = \text{(Total Faces)}\ /\ \text{vsa_face_patch_ratio}\]</div>
<p>Rather than set the number of patches explicitly, which is mesh dependent, expressing this
parameter as a ratio allows the same value to apply to a variety of meshes.</p>
</section>
<section id="vsa-max-patch-radius">
<h3>VSA_MAX_PATCH_RADIUS<a class="headerlink" href="#vsa-max-patch-radius" title="Link to this heading"></a></h3>
<p>Defines the desired maximum radius for a patch.</p>
<blockquote class="nml-param">
<div><p><strong>Type:</strong> <code class="docutils literal notranslate"><span class="pre">REAL</span></code></p>
<p><strong>Domain:</strong> vsa_max_patch_radius &gt; 0.0</p>
<p><strong>Default:</strong> vsa_max_patch_radius = sqrt(huge(0.0_r8))</p>
</div></blockquote>
<p>This parameter is used to compute the <em>size bias</em> term of the weight of a face relative to
a patch proxy. Refer to the <a class="reference internal" href="#size-bias"><span class="std std-ref">size bias section</span></a> of the
VSA documentation for more information on how the parameter affects the face weight computation.</p>
<p>Note that the default value of this parameter is <code class="code highlight fortran docutils literal highlight-fortran"><span class="nb">sqrt</span><span class="p">(</span><span class="nb">huge</span><span class="p">(</span><span class="mf">0.0_r8</span><span class="p">))</span></code> because it is squared
in the face weight computation. By taking the root of <code class="code highlight fortran docutils literal highlight-fortran"><span class="nb">huge</span><span class="p">(</span><span class="mf">0.0_r8</span><span class="p">)</span></code> we prevent floating
point overflow errors. Numerically, the default value on the order of <span class="math notranslate nohighlight">\(1.34*10^{154}\)</span>.</p>
</section>
<section id="vsa-normalize-dist">
<h3>VSA_NORMALIZE_DIST<a class="headerlink" href="#vsa-normalize-dist" title="Link to this heading"></a></h3>
<p>Determines whether to normalize the distance bias.</p>
<blockquote class="nml-param">
<div><p><strong>Type:</strong> <code class="docutils literal notranslate"><span class="pre">LOGICAL</span></code></p>
<p><strong>Domain:</strong> Must be <code class="docutils literal notranslate"><span class="pre">.true.</span></code> or <code class="docutils literal notranslate"><span class="pre">.false.</span></code></p>
<p><strong>Default:</strong> vsa_normalize_dist = <code class="docutils literal notranslate"><span class="pre">.true.</span></code></p>
</div></blockquote>
<p>This parameter affects the computation of the <em>distance bias</em> term of the weight of a face relative
to a patch proxy. Broadly speaking, enabling normalization tends to produce patches with a similar
number of faces, regardless of the physical size of each patch. Conversely, disabling normalization
tends to make all patches about the same physical size, regardless of the number of faces in each
patch.</p>
<p>Refer to the <a class="reference internal" href="#distance-bias"><span class="std std-ref">distance bias section</span></a>
of the VSA documentation for more information on how the parameter affects the face weight
computation.</p>
</section>
<section id="vsa-random-seed">
<h3>VSA_RANDOM_SEED<a class="headerlink" href="#vsa-random-seed" title="Link to this heading"></a></h3>
<p>Defines the seed for the random number generator used to pick the initial seed patches.</p>
<blockquote class="nml-param">
<div><p><strong>Type:</strong> <code class="docutils literal notranslate"><span class="pre">INTEGER</span></code></p>
<p><strong>Domain:</strong> pave_random_seed &gt; 0</p>
<p><strong>Default:</strong> <code class="docutils literal notranslate"><span class="pre">NONE</span></code>, the seed is taken from the system clock.</p>
</div></blockquote>
<p>The VSA algorithm uses a ‘farthest-point’ initialization method to choose the seed patches for the
first iteration. To start, a random face in each connected component is chosen as a seed patch.
Then, seed patches are added one at a time by performing a <a class="reference internal" href="#geometry-partitioning"><span class="std std-ref">partitioning</span></a> and then choosing the face with highest total
distortion as the new seed patch.</p>
<p>This parameter sets the seed for the random number generator used to pick the first seed patch in
each connected component. Therefore, runs with the same value for this parameter will produce
identical results. If this parameter is not specified, then the seed is taken from the system clock
and results will likely vary from run to run.</p>
</section>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Link to this heading"></a></h2>
<div class="docutils container" id="id5">
<div role="list" class="citation-list">
<div class="citation" id="id6" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id1">1</a>,<a role="doc-backlink" href="#id2">2</a>,<a role="doc-backlink" href="#id3">3</a>,<a role="doc-backlink" href="#id4">4</a>)</span>
<p>David Cohen-Steiner, Pierre Alliez, and Mathieu Desbrun. Variational Shape Approximation. In <em>ACM SIGGRAPH 2004 Papers</em>, SIGGRAPH '04, 905–914. New York, NY, USA, 2004. ACM. <a class="reference external" href="https://doi.org/10.1145/1186562.1015817">doi:10.1145/1186562.1015817</a>.</p>
</div>
</div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="pave.html" class="btn btn-neutral float-left" title="Vertex Anchor Cluster Paving (PAVE)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="metis.html" class="btn btn-neutral float-right" title="METIS patching (METIS)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Los Alamos National Laboratory.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>