<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PATCHES Namelist &mdash; Truchas 1.0 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/sphinxdoc.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/custom.css" type="text/css" />
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Sphinx Documentation Style Guide" href="../../../style_guide.html" />
    <link rel="prev" title="Vertex Anchor Cluster (VAC)" href="vac.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> Truchas
            <img src="../../../_static/logo.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Radiation Enclosure Tools</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../index.html#contents">Contents</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="index.html">Enclosure Patches</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="index.html#patch-algorithms">Patch Algorithms</a></li>
<li class="toctree-l4 current"><a class="reference internal" href="index.html#patches-namelist">PATCHES Namelist</a><ul class="current">
<li class="toctree-l5 current"><a class="current reference internal" href="#">PATCHES Namelist</a><ul>
<li class="toctree-l6"><a class="reference internal" href="#general-parameters">General Parameters</a><ul>
<li class="toctree-l7"><a class="reference internal" href="#patch-algorithm">PATCH_ALGORITHM</a></li>
<li class="toctree-l7"><a class="reference internal" href="#verbosity-level">VERBOSITY_LEVEL</a></li>
<li class="toctree-l7"><a class="reference internal" href="#max-angle">MAX_ANGLE</a></li>
</ul>
</li>
<li class="toctree-l6"><a class="reference internal" href="#file-parameters">FILE Parameters</a><ul>
<li class="toctree-l7"><a class="reference internal" href="#patch-file">PATCH_FILE</a></li>
</ul>
</li>
<li class="toctree-l6"><a class="reference internal" href="#pave-parameters">PAVE Parameters</a><ul>
<li class="toctree-l7"><a class="reference internal" href="#pave-merge-level">PAVE_MERGE_LEVEL</a></li>
<li class="toctree-l7"><a class="reference internal" href="#pave-split-patch-size">PAVE_SPLIT_PATCH_SIZE</a></li>
<li class="toctree-l7"><a class="reference internal" href="#pave-random-seed">PAVE_RANDOM_SEED</a></li>
</ul>
</li>
<li class="toctree-l6"><a class="reference internal" href="#vac-parameters">VAC Parameters</a><ul>
<li class="toctree-l7"><a class="reference internal" href="#vac-merge-level">VAC_MERGE_LEVEL</a></li>
<li class="toctree-l7"><a class="reference internal" href="#vac-split-patch-size">VAC_SPLIT_PATCH_SIZE</a></li>
</ul>
</li>
<li class="toctree-l6"><a class="reference internal" href="#vsa-parameters">VSA Parameters</a><ul>
<li class="toctree-l7"><a class="reference internal" href="#vsa-max-iter">VSA_MAX_ITER</a></li>
<li class="toctree-l7"><a class="reference internal" href="#vsa-min-delta">VSA_MIN_DELTA</a></li>
<li class="toctree-l7"><a class="reference internal" href="#vsa-face-patch-ratio">VSA_FACE_PATCH_RATIO</a></li>
<li class="toctree-l7"><a class="reference internal" href="#vsa-max-patch-radius">VSA_MAX_PATCH_RADIUS</a></li>
<li class="toctree-l7"><a class="reference internal" href="#vsa-normalize-dist">VSA_NORMALIZE_DIST</a></li>
<li class="toctree-l7"><a class="reference internal" href="#vsa-random-seed">VSA_RANDOM_SEED</a></li>
</ul>
</li>
<li class="toctree-l6"><a class="reference internal" href="#metis-parameters">METIS Parameters</a><ul>
<li class="toctree-l7"><a class="reference internal" href="#initialization-parameters">Initialization Parameters</a><ul>
<li class="toctree-l8"><a class="reference internal" href="#metis-face-patch-ratio">METIS_FACE_PATCH_RATIO</a></li>
<li class="toctree-l8"><a class="reference internal" href="#metis-edge-weight">METIS_EDGE_WEIGHT</a></li>
<li class="toctree-l8"><a class="reference internal" href="#metis-face-weight">METIS_FACE_WEIGHT</a></li>
</ul>
</li>
<li class="toctree-l7"><a class="reference internal" href="#metis-library-parameters">METIS library parameters</a><ul>
<li class="toctree-l8"><a class="reference internal" href="#metis-ptype">METIS_PTYPE</a></li>
<li class="toctree-l8"><a class="reference internal" href="#metis-objtype">METIS_OBJTYPE</a></li>
<li class="toctree-l8"><a class="reference internal" href="#metis-ctype">METIS_CTYPE</a></li>
<li class="toctree-l8"><a class="reference internal" href="#metis-iptype">METIS_IPTYPE</a></li>
<li class="toctree-l8"><a class="reference internal" href="#metis-ncuts">METIS_NCUTS</a></li>
<li class="toctree-l8"><a class="reference internal" href="#metis-niter">METIS_NITER</a></li>
<li class="toctree-l8"><a class="reference internal" href="#metis-seed">METIS_SEED</a></li>
<li class="toctree-l8"><a class="reference internal" href="#metis-minconn">METIS_MINCONN</a></li>
<li class="toctree-l8"><a class="reference internal" href="#metis-no2hop">METIS_NO2HOP</a></li>
<li class="toctree-l8"><a class="reference internal" href="#metis-contig">METIS_CONTIG</a></li>
<li class="toctree-l8"><a class="reference internal" href="#metis-ufactor">METIS_UFACTOR</a></li>
<li class="toctree-l8"><a class="reference internal" href="#metis-dbglvl">METIS_DBGLVL</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l6"><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="index.html#references">References</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Truchas</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Radiation Enclosure Tools</a> &raquo;</li>
          <li><a href="index.html">Enclosure Patches</a> &raquo;</li>
      <li>PATCHES Namelist</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../_sources/tools/RadE/patches/patches_namelist.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="patches-namelist">
<h1>PATCHES Namelist<a class="headerlink" href="#patches-namelist" title="Permalink to this headline"></a></h1>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">&amp;PATCHES</span>
<span class="go">  patch_algorithm = &#39;PAVE&#39;</span>
<span class="go">  verbosity_level = 3</span>
<span class="go">  max_angle = 30.0</span>
<span class="go">  pave_split_patch_size = 4</span>
<span class="go">/</span>
</pre></div>
</div>
<p><sup>Example PATCHES namelist</sup></p>
<p>The <cite>PATCHES</cite> namelist defines the parameters used by the patching algorithms. The namelist supports
many parameters, but not all parameters are used by all algorithms. Parameters only used by a
particular algorithm are prefixed with the algorithm’s name.</p>
<p>These parameters are described in detail below.</p>
<div class="contents local topic" id="patches-namelist-parameters">
<p class="topic-title">PATCHES namelist parameters</p>
<ul class="simple">
<li><p><a class="reference internal" href="#general-parameters" id="id9">General Parameters</a></p>
<ul>
<li><p><a class="reference internal" href="#patch-algorithm" id="id10">PATCH_ALGORITHM</a></p></li>
<li><p><a class="reference internal" href="#verbosity-level" id="id11">VERBOSITY_LEVEL</a></p></li>
<li><p><a class="reference internal" href="#max-angle" id="id12">MAX_ANGLE</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#file-parameters" id="id13">FILE Parameters</a></p>
<ul>
<li><p><a class="reference internal" href="#patch-file" id="id14">PATCH_FILE</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#pave-parameters" id="id15">PAVE Parameters</a></p>
<ul>
<li><p><a class="reference internal" href="#pave-merge-level" id="id16">PAVE_MERGE_LEVEL</a></p></li>
<li><p><a class="reference internal" href="#pave-split-patch-size" id="id17">PAVE_SPLIT_PATCH_SIZE</a></p></li>
<li><p><a class="reference internal" href="#pave-random-seed" id="id18">PAVE_RANDOM_SEED</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#vac-parameters" id="id19">VAC Parameters</a></p>
<ul>
<li><p><a class="reference internal" href="#vac-merge-level" id="id20">VAC_MERGE_LEVEL</a></p></li>
<li><p><a class="reference internal" href="#vac-split-patch-size" id="id21">VAC_SPLIT_PATCH_SIZE</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#vsa-parameters" id="id22">VSA Parameters</a></p>
<ul>
<li><p><a class="reference internal" href="#vsa-max-iter" id="id23">VSA_MAX_ITER</a></p></li>
<li><p><a class="reference internal" href="#vsa-min-delta" id="id24">VSA_MIN_DELTA</a></p></li>
<li><p><a class="reference internal" href="#vsa-face-patch-ratio" id="id25">VSA_FACE_PATCH_RATIO</a></p></li>
<li><p><a class="reference internal" href="#vsa-max-patch-radius" id="id26">VSA_MAX_PATCH_RADIUS</a></p></li>
<li><p><a class="reference internal" href="#vsa-normalize-dist" id="id27">VSA_NORMALIZE_DIST</a></p></li>
<li><p><a class="reference internal" href="#vsa-random-seed" id="id28">VSA_RANDOM_SEED</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#metis-parameters" id="id29">METIS Parameters</a></p>
<ul>
<li><p><a class="reference internal" href="#initialization-parameters" id="id30">Initialization Parameters</a></p>
<ul>
<li><p><a class="reference internal" href="#metis-face-patch-ratio" id="id31">METIS_FACE_PATCH_RATIO</a></p></li>
<li><p><a class="reference internal" href="#metis-edge-weight" id="id32">METIS_EDGE_WEIGHT</a></p></li>
<li><p><a class="reference internal" href="#metis-face-weight" id="id33">METIS_FACE_WEIGHT</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#metis-library-parameters" id="id34">METIS library parameters</a></p>
<ul>
<li><p><a class="reference internal" href="#metis-ptype" id="id35">METIS_PTYPE</a></p></li>
<li><p><a class="reference internal" href="#metis-objtype" id="id36">METIS_OBJTYPE</a></p></li>
<li><p><a class="reference internal" href="#metis-ctype" id="id37">METIS_CTYPE</a></p></li>
<li><p><a class="reference internal" href="#metis-iptype" id="id38">METIS_IPTYPE</a></p></li>
<li><p><a class="reference internal" href="#metis-ncuts" id="id39">METIS_NCUTS</a></p></li>
<li><p><a class="reference internal" href="#metis-niter" id="id40">METIS_NITER</a></p></li>
<li><p><a class="reference internal" href="#metis-seed" id="id41">METIS_SEED</a></p></li>
<li><p><a class="reference internal" href="#metis-minconn" id="id42">METIS_MINCONN</a></p></li>
<li><p><a class="reference internal" href="#metis-no2hop" id="id43">METIS_NO2HOP</a></p></li>
<li><p><a class="reference internal" href="#metis-contig" id="id44">METIS_CONTIG</a></p></li>
<li><p><a class="reference internal" href="#metis-ufactor" id="id45">METIS_UFACTOR</a></p></li>
<li><p><a class="reference internal" href="#metis-dbglvl" id="id46">METIS_DBGLVL</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#references" id="id47">References</a></p></li>
</ul>
</div>
<section id="general-parameters">
<h2>General Parameters<a class="headerlink" href="#general-parameters" title="Permalink to this headline"></a></h2>
<section id="patch-algorithm">
<h3>PATCH_ALGORITHM<a class="headerlink" href="#patch-algorithm" title="Permalink to this headline"></a></h3>
<p>Selects one of the available algorithms, or disables patching.</p>
<blockquote class="nml-param">
<div><p><strong>Type:</strong> <code class="docutils literal notranslate"><span class="pre">STRING</span></code></p>
<p><strong>Domain:</strong> Must be one of <code class="docutils literal notranslate"><span class="pre">'NONE'</span></code>, <code class="docutils literal notranslate"><span class="pre">'PAVE'</span></code>, <code class="docutils literal notranslate"><span class="pre">'VAC'</span></code>, <code class="docutils literal notranslate"><span class="pre">'VSA'</span></code>, <code class="docutils literal notranslate"><span class="pre">'METIS'</span></code>, or <code class="docutils literal notranslate"><span class="pre">'FILE'</span></code></p>
<p><strong>Default:</strong> patch_algorithm = <code class="docutils literal notranslate"><span class="pre">'PAVE'</span></code></p>
</div></blockquote>
<p>Each option selects a different patch algorithm:</p>
<ol class="arabic simple">
<li><p><strong>NONE:</strong> No patches will be generated. All other parameters are ignored. This is equivalent to
an absent <cite>PATCHES</cite> namelist.</p></li>
<li><p><strong>PAVE:</strong> Generate patches with the <a class="reference internal" href="pave.html"><span class="doc">PAVE algorithm</span></a>.</p></li>
<li><p><strong>VAC:</strong> Generate patches with the <a class="reference internal" href="vac.html"><span class="doc">VAC algorithm</span></a>.</p></li>
<li><p><strong>VSA:</strong> Generate patches with the <a class="reference internal" href="vsa.html"><span class="doc">VSA algorithm</span></a>.</p></li>
<li><p><strong>METIS:</strong> Generate patches with the <a class="reference internal" href="metis.html"><span class="doc">METIS algorithm</span></a>.</p></li>
<li><p><strong>FILE:</strong> Patches will be read from a file. Because the cost of computing
patches can be quite substantial for very large enclosure meshes, this
pseudo-algorithm is provided to enable the use of previously computed
patches.</p></li>
</ol>
</section>
<section id="verbosity-level">
<h3>VERBOSITY_LEVEL<a class="headerlink" href="#verbosity-level" title="Permalink to this headline"></a></h3>
<p>Defines the verbosity level for all console output of the patch algorithm.</p>
<blockquote class="nml-param">
<div><p><strong>Type:</strong> <code class="docutils literal notranslate"><span class="pre">INTEGER</span></code></p>
<p><strong>Domain:</strong> verbosity_level &gt;= 0</p>
<p><strong>Default:</strong> verbosity_level = 1</p>
</div></blockquote>
<p>The verbosity levels are defined as follows:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 67%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>verbosity_level = 0</p></td>
<td><p>Suppress all output.</p></td>
</tr>
<tr class="row-odd"><td><p>verbosity_level = 1</p></td>
<td><p>Print a summary of the run when algorithm finishes.</p></td>
</tr>
<tr class="row-even"><td><p>verbosity_level &gt; 1</p></td>
<td><p>Print detailed run information, used for debugging.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="max-angle">
<h3>MAX_ANGLE<a class="headerlink" href="#max-angle" title="Permalink to this headline"></a></h3>
<p>Defines the maximum allowable angle (in degrees) between adjacent faces.</p>
<blockquote class="nml-param">
<div><p><strong>Type:</strong> <code class="docutils literal notranslate"><span class="pre">REAL</span></code></p>
<p><strong>Domain:</strong> 0.0 &lt;= max_angle &lt;= 180.0</p>
<p><strong>Default:</strong> max_angle = 20.0</p>
</div></blockquote>
<p>All the patch algorithms construct the <a class="reference external" href="http://mathworld.wolfram.com/AdjacencyMatrix.html">adjacency matrix</a> of the enclosure faces to efficiently
determine which faces are adjacent to others. If the normals of two ‘topologically adjacent’ faces
exceed <em>max_angle</em>, then the faces will not be neighbors in the internal adjacency matrix.</p>
<figure class="align-center" id="id8" style="width: 45%">
<img alt="../../../_images/connected_components.png" src="../../../_images/connected_components.png" />
<figcaption>
<p><span class="caption-text">The connected components of the outer surface of a furnace funnel. MAX_ANGLE is set to 20
degrees. Each component is a different color. The face edges are omitted for clarity.</span><a class="headerlink" href="#id8" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>The patch algorithms guarantee that patches will be <em>connected sets</em> of faces. Therefore,
<code class="docutils literal notranslate"><span class="pre">max_angle</span></code> divides the enclosure into connected components of faces wherever there are ‘sharp’
edges whose angle exceeds the parameter. Patches will never span more than one component.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">max_angle</span></code> only applies to <em>pairs of adjacent faces</em>, so two faces within a patch may be at an
angle greater than <code class="docutils literal notranslate"><span class="pre">max_angle</span></code> if the faces between them are at sufficiently large angles. This
is unlikely in practice, given a reasonably smooth enclosure and small <code class="docutils literal notranslate"><span class="pre">max_angle</span></code>.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>The effects of <code class="docutils literal notranslate"><span class="pre">max_angle</span></code> vary by algorithm. Refer to the documentation of the <a class="reference internal" href="pave.html"><span class="doc">PAVE</span></a>, <a class="reference internal" href="vac.html"><span class="doc">VAC</span></a>, and <a class="reference internal" href="vsa.html"><span class="doc">VSA</span></a> algorithms for more details.</p>
</div>
</section>
</section>
<section id="file-parameters">
<h2>FILE Parameters<a class="headerlink" href="#file-parameters" title="Permalink to this headline"></a></h2>
<p>The following namelist parameter applies only to the FILE algorithm.</p>
<section id="patch-file">
<h3>PATCH_FILE<a class="headerlink" href="#patch-file" title="Permalink to this headline"></a></h3>
<p>The path to an existing radiation enclosure file containing patch information.</p>
<blockquote class="nml-param">
<div><p><strong>Type:</strong> <code class="docutils literal notranslate"><span class="pre">STRING</span></code></p>
<p><strong>Domain:</strong> patch_file must be a valid path</p>
<p><strong>Default:</strong> patch_file = <code class="docutils literal notranslate"><span class="pre">''</span></code></p>
</div></blockquote>
<p>The enclosure defined by the file must be identical to the current enclosure. This may be an
absolute path or a relative path.</p>
</section>
</section>
<section id="pave-parameters">
<h2>PAVE Parameters<a class="headerlink" href="#pave-parameters" title="Permalink to this headline"></a></h2>
<p>The following namelist parameters apply only to the PAVE algorithm. For more
information, refer to the <a class="reference internal" href="pave.html"><span class="doc">PAVE algorithm documentation</span></a>.</p>
<section id="pave-merge-level">
<h3>PAVE_MERGE_LEVEL<a class="headerlink" href="#pave-merge-level" title="Permalink to this headline"></a></h3>
<p>Controls the aggressiveness of patch merging.</p>
<blockquote class="nml-param">
<div><p><strong>Type:</strong> <code class="docutils literal notranslate"><span class="pre">INTEGER</span></code></p>
<p><strong>Domain:</strong> pave_merge_level &gt;= 0</p>
<p><strong>Default:</strong> pave_merge_level = 3</p>
</div></blockquote>
<p>After paving is complete, there will be a valid patching of the enclosure. The algorithm then
attempts to merge patches in order to reduce the patch count.</p>
<p>The merge levels are defined as follows:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 67%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>pave_merge_level = 0</p></td>
<td><p>No merging.</p></td>
</tr>
<tr class="row-odd"><td><p>pave_merge_level = 1</p></td>
<td><p>Merge patches that are within the faces of a vertex.</p></td>
</tr>
<tr class="row-even"><td><p>pave_merge_level = 2</p></td>
<td><p>Same as 1. Additionally, merge patches that are within the faces of pairs
of adjacent vertices. The old patches are requeued with their original
weight so that a merge is only performed if the merge candidate has a
lower weight than any of its consituent patches.</p></td>
</tr>
<tr class="row-odd"><td><p>pave_merge_level &gt;= 3</p></td>
<td><p>Same as 2. Additionally, merge patches within the faces of pairs of
adjacent vertices, but add a large weight to the requeued old patches.
This ensures that the merge is always performed.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="pave-split-patch-size">
<h3>PAVE_SPLIT_PATCH_SIZE<a class="headerlink" href="#pave-split-patch-size" title="Permalink to this headline"></a></h3>
<p>Defines the maximum size of patches to be split during patch merging.</p>
<blockquote class="nml-param">
<div><p><strong>Type:</strong> <code class="docutils literal notranslate"><span class="pre">INTEGER</span></code></p>
<p><strong>Domain:</strong> pave_split_patch_size &gt; 1</p>
<p><strong>Default:</strong> pave_split_patch_size = 3</p>
</div></blockquote>
<p>Before merging patches, all <a class="reference internal" href="#pave-merge-level"><span class="std std-ref">merge methods</span></a> find patches with less than
<code class="docutils literal notranslate"><span class="pre">pave_split_patch_size</span></code> faces and ‘split’ them into 1-face patches. The original patches aren’t
actually modified, rather they are re-queued along with their constituent faces. This allows the
algorithm to find more merge candidates and then ‘fill in the gaps’ with the 1-face patches.</p>
<p>The 1-face patches have a large weight, so they will only be used after all other patches are set.
Therefore, the enclosure will tend retain the same patches as before the split, unless this is not
possible due to a merge.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For best results, set <code class="docutils literal notranslate"><span class="pre">pave_split_patch_size</span></code> to 3 for quadrilateral meshes
and to 5 for triangular meshes. This avoids splitting too many patches.</p>
</div>
</section>
<section id="pave-random-seed">
<h3>PAVE_RANDOM_SEED<a class="headerlink" href="#pave-random-seed" title="Permalink to this headline"></a></h3>
<p>Defines the seed for the random number generator used to pick the initial seed patches.</p>
<blockquote class="nml-param">
<div><p><strong>Type:</strong> <code class="docutils literal notranslate"><span class="pre">INTEGER</span></code></p>
<p><strong>Domain:</strong> pave_random_seed &gt; 0</p>
<p><strong>Default:</strong> <code class="docutils literal notranslate"><span class="pre">NONE</span></code>, the seed is taken from the system clock.</p>
</div></blockquote>
<p>The PAVE algorithm begins by creating a ‘seed patch’ in each connected component of the enclosure.
Each component is then ‘paved’ or ‘tiled’ with patches, starting from the seed patch. The seed
patches are chosen randomly from a set of patches determined to produce optimal results. Refer to
the <a class="reference internal" href="pave.html#choosing-seed-patches"><span class="std std-ref">seed patches section</span></a> of the PAVE
documentation for more information on how the seed patches are selected.</p>
<p>This parameter sets the seed for the random number generator used to pick the seed patches.
Therefore, runs with the same value for this parameter will produce identical results. If this
parameter is not specified, then the seed is taken from the system clock and results will likely
vary from run to run.</p>
</section>
</section>
<section id="vac-parameters">
<h2>VAC Parameters<a class="headerlink" href="#vac-parameters" title="Permalink to this headline"></a></h2>
<p>The following namelist parameters apply only to the VAC algorithm. For more
information, refer to the <a class="reference internal" href="vac.html"><span class="doc">VAC algorithm documentation</span></a>.</p>
<section id="vac-merge-level">
<h3>VAC_MERGE_LEVEL<a class="headerlink" href="#vac-merge-level" title="Permalink to this headline"></a></h3>
<p>Controls the aggressiveness of patch merging.</p>
<blockquote class="nml-param">
<div><p><strong>Type:</strong> <code class="docutils literal notranslate"><span class="pre">INTEGER</span></code></p>
<p><strong>Domain:</strong> vac_merge_level &gt;= 0</p>
<p><strong>Default:</strong> vac_merge_level = 3</p>
</div></blockquote>
<p>After the main stage of the VAC algorithm, there will be a valid patching of the enclosure. The
algorithm then attempts to merge patches in order to reduce the patch count.</p>
<p>The merge levels are defined as follows:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 67%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>vac_merge_level = 0</p></td>
<td><p>No merging.</p></td>
</tr>
<tr class="row-odd"><td><p>vac_merge_level = 1</p></td>
<td><p>Merge patches that are within the faces of a vertex.</p></td>
</tr>
<tr class="row-even"><td><p>vac_merge_level = 2</p></td>
<td><p>Same as 1. Additionally, merge patches that are within the faces of pairs
of adjacent vertices. The old patches are requeued with their original
weight so that a merge is only performed if the merge candidate has a
lower weight than any of its consituent patches.</p></td>
</tr>
<tr class="row-odd"><td><p>vac_merge_level &gt;= 3</p></td>
<td><p>Same as 2. Additionally, merge patches within the faces of pairs of
adjacent vertices, but add a large weight to the requeued old patches.
This ensures that the merge is always performed.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="vac-split-patch-size">
<h3>VAC_SPLIT_PATCH_SIZE<a class="headerlink" href="#vac-split-patch-size" title="Permalink to this headline"></a></h3>
<p>Defines the maximum size of patches to be split during patch merging.</p>
<blockquote class="nml-param">
<div><p><strong>Type:</strong> <code class="docutils literal notranslate"><span class="pre">INTEGER</span></code></p>
<p><strong>Domain:</strong> vac_split_patch_size &gt; 1</p>
<p><strong>Default:</strong> vac_split_patch_size = 3</p>
</div></blockquote>
<p>Before merging patches, all <a class="reference internal" href="#vac-merge-level"><span class="std std-ref">merge methods</span></a> find patches with less than
<code class="docutils literal notranslate"><span class="pre">vac_split_patch_size</span></code> faces and ‘split’ them into 1-face patches. The original patches aren’t
actually modified, rather they are re-queued along with their constituent faces. This allows the
algorithm to find more merge candidates and then ‘fill in the gaps’ with the 1-face patches.</p>
<p>The 1-face patches have a large weight, so they will only be used after all other patches are set.
Therefore, the enclosure will tend retain the same patches as before the split, unless this is not
possible due to a merge.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For best results, set <code class="docutils literal notranslate"><span class="pre">vac_split_patch_size</span></code> to 3 for quadrilateral meshes
and to 5 for triangular meshes. This avoids splitting too many patches.</p>
</div>
</section>
</section>
<section id="vsa-parameters">
<h2>VSA Parameters<a class="headerlink" href="#vsa-parameters" title="Permalink to this headline"></a></h2>
<p>The following namelist parameters apply only to the VSA algorithm. For more
information, refer to the <a class="reference internal" href="vsa.html"><span class="doc">VSA algorithm documentation</span></a>.</p>
<section id="vsa-max-iter">
<h3>VSA_MAX_ITER<a class="headerlink" href="#vsa-max-iter" title="Permalink to this headline"></a></h3>
<p>Defines the maximum number of iterations.</p>
<blockquote class="nml-param">
<div><p><strong>Type:</strong> <code class="docutils literal notranslate"><span class="pre">INTEGER</span></code></p>
<p><strong>Domain:</strong> vsa_max_iter &gt;= 1</p>
<p><strong>Default:</strong> vsa_max_iter = 1000</p>
</div></blockquote>
<p>The algorithm stops when <code class="docutils literal notranslate"><span class="pre">vsa_max_iter</span></code> is reached, regardless of other
terminating conditions.</p>
</section>
<section id="vsa-min-delta">
<h3>VSA_MIN_DELTA<a class="headerlink" href="#vsa-min-delta" title="Permalink to this headline"></a></h3>
<p>Defines the minimum allowable change in patch proxies between successive iterations.</p>
<blockquote class="nml-param">
<div><p><strong>Type:</strong> <code class="docutils literal notranslate"><span class="pre">REAL</span></code></p>
<p><strong>Domain:</strong> vsa_min_delta &gt;= 0.0</p>
<p><strong>Default:</strong> vsa_min_delta = 1.0E-6</p>
</div></blockquote>
<p>At the end of each iteration, the new patch proxies for the next iteration are computed and compared
against the old proxies. The algorithm keeps track of the <em>minimum</em> change between the old and new
proxies. This change is computed as the sum of the squares of the difference between the old and new
proxy vectors. If the minimum change in patch proxies is less than <code class="docutils literal notranslate"><span class="pre">vsa_min_delta</span></code>, the algorithm
stops at that iteration.</p>
</section>
<section id="vsa-face-patch-ratio">
<h3>VSA_FACE_PATCH_RATIO<a class="headerlink" href="#vsa-face-patch-ratio" title="Permalink to this headline"></a></h3>
<p>Defines the ratio of total faces to total patches, and by extension the total number of patches.</p>
<blockquote class="nml-param">
<div><p><strong>Type:</strong> <code class="docutils literal notranslate"><span class="pre">REAL</span></code></p>
<p><strong>Domain:</strong> vsa_face_patch_ratio &gt;= 1.0</p>
<p><strong>Default:</strong> vsa_face_patch_ratio = 4.0</p>
</div></blockquote>
<p>Since the number of faces is fixed, this parameter determines the total number of patches in the
final configuration:</p>
<div class="math notranslate nohighlight">
\[\text{(Total Patches)} = \text{(Total Faces)}\ /\ \text{vsa_face_patch_ratio}\]</div>
<p>Rather than set the number of patches explicitly, which is mesh dependent, expressing this
parameter as a ratio allows the same value to apply to a variety of meshes.</p>
</section>
<section id="vsa-max-patch-radius">
<h3>VSA_MAX_PATCH_RADIUS<a class="headerlink" href="#vsa-max-patch-radius" title="Permalink to this headline"></a></h3>
<p>Defines the desired maximum radius for a patch.</p>
<blockquote class="nml-param">
<div><p><strong>Type:</strong> <code class="docutils literal notranslate"><span class="pre">REAL</span></code></p>
<p><strong>Domain:</strong> vsa_max_patch_radius &gt; 0.0</p>
<p><strong>Default:</strong> vsa_max_patch_radius = sqrt(huge(0.0_r8))</p>
</div></blockquote>
<p>This parameter is used to compute the <em>size bias</em> term of the weight of a face relative to
a patch proxy. Refer to the <a class="reference internal" href="vsa.html#size-bias"><span class="std std-ref">size bias section</span></a> of the
VSA documentation for more information on how the parameter affects the face weight computation.</p>
<p>Note that the default value of this parameter is <code class="code fortran docutils literal notranslate"><span class="name builtin"><span class="pre">sqrt</span></span><span class="punctuation"><span class="pre">(</span></span><span class="name builtin"><span class="pre">huge</span></span><span class="punctuation"><span class="pre">(</span></span><span class="literal number float"><span class="pre">0.0_r8</span></span><span class="punctuation"><span class="pre">))</span></span></code> because it is squared
in the face weight computation. By taking the root of <code class="code fortran docutils literal notranslate"><span class="name builtin"><span class="pre">huge</span></span><span class="punctuation"><span class="pre">(</span></span><span class="literal number float"><span class="pre">0.0_r8</span></span><span class="punctuation"><span class="pre">)</span></span></code> we prevent floating
point overflow errors. Numerically, the default value on the order of <cite>1.34*10^{154}</cite>.</p>
</section>
<section id="vsa-normalize-dist">
<h3>VSA_NORMALIZE_DIST<a class="headerlink" href="#vsa-normalize-dist" title="Permalink to this headline"></a></h3>
<p>Determines whether to normalize the distance bias.</p>
<blockquote class="nml-param">
<div><p><strong>Type:</strong> <code class="docutils literal notranslate"><span class="pre">LOGICAL</span></code></p>
<p><strong>Domain:</strong> Must be <code class="docutils literal notranslate"><span class="pre">.true.</span></code> or <code class="docutils literal notranslate"><span class="pre">.false.</span></code></p>
<p><strong>Default:</strong> vsa_normalize_dist = <code class="docutils literal notranslate"><span class="pre">.true.</span></code></p>
</div></blockquote>
<p>This parameter affects the computation of the <em>distance bias</em> term of the weight of a face relative
to a patch proxy. Broadly speaking, enabling normalization tends to produce patches with a similar
number of faces, regardless of the physical size of each patch. Conversely, disabling normalization
tends to make all patches about the same physical size, regardless of the number of faces in each
patch.</p>
<p>Refer to the <a class="reference internal" href="vsa.html#distance-bias"><span class="std std-ref">distance bias section</span></a>
of the VSA documentation for more information on how the parameter affects the face weight
computation.</p>
</section>
<section id="vsa-random-seed">
<h3>VSA_RANDOM_SEED<a class="headerlink" href="#vsa-random-seed" title="Permalink to this headline"></a></h3>
<p>Defines the seed for the random number generator used to pick the initial seed patches.</p>
<blockquote class="nml-param">
<div><p><strong>Type:</strong> <code class="docutils literal notranslate"><span class="pre">INTEGER</span></code></p>
<p><strong>Domain:</strong> pave_random_seed &gt; 0</p>
<p><strong>Default:</strong> <code class="docutils literal notranslate"><span class="pre">NONE</span></code>, the seed is taken from the system clock.</p>
</div></blockquote>
<p>The VSA algorithm uses a ‘farthest-point’ initialization method to choose the seed patches for the
first iteration. To start, a random face in each connected component of the enclosure is chosen as a
seed patch. Then, seed patches are added one at a time by performing a <a class="reference internal" href="vsa.html#geometry-partitioning"><span class="std std-ref">partitioning</span></a> and then choosing the face with highest total
distortion as the new seed patch.</p>
<p>This parameter sets the seed for the random number generator used to pick the first seed patch in
each connected component. Therefore, runs with the same value for this parameter will produce
identical results. If this parameter is not specified, then the seed is taken from the system clock
and results will likely vary from run to run.</p>
</section>
</section>
<section id="metis-parameters">
<h2>METIS Parameters<a class="headerlink" href="#metis-parameters" title="Permalink to this headline"></a></h2>
<p>The following namelist parameters apply only to the METIS algorithm. For more
information, refer to the <a class="reference internal" href="metis.html"><span class="doc">METIS algorithm documentation</span></a>.</p>
<p>The METIS algorithm constructs the weighted dual graph of the enclosure and passes it to the METIS
library <span id="id1">[<a class="reference internal" href="#id7" title="George Karypis and Vipin Kumar. A fast and high quality multilevel scheme for partitioning irregular graphs. SIAM J. Sci. Comput., 20(1):359–392, December 1998.">1</a>]</span> to partition the dual graph. The METIS namelist
parameters are thus divided into two: those that are used to construct the dual graph, and those
that are passed directly to the METIS graph partitioner.</p>
<p>We first discuss the three parameters used during initialization, and then briefly present the 12
METIS library parameters passed to the graph partitioner.</p>
<section id="initialization-parameters">
<h3>Initialization Parameters<a class="headerlink" href="#initialization-parameters" title="Permalink to this headline"></a></h3>
<section id="metis-face-patch-ratio">
<h4>METIS_FACE_PATCH_RATIO<a class="headerlink" href="#metis-face-patch-ratio" title="Permalink to this headline"></a></h4>
<p>Defines the ratio of total faces to total desired patches, and by extension the final number of
patches generated.</p>
<blockquote class="nml-param">
<div><p><strong>Type:</strong> <code class="docutils literal notranslate"><span class="pre">REAL</span></code></p>
<p><strong>Domain:</strong> metis_face_patch_ratio &gt;= 1.0</p>
<p><strong>Default:</strong> meti_face_patch_ratio = 4.0</p>
</div></blockquote>
<p>This parameter determines the number of partitions NPART passed to the METIS graph partitioner:</p>
<div class="math notranslate nohighlight">
\[\text{NPART} = \frac{\text{NFACE}}{\text{METIS_FACE_PATCH_RATIO}}\]</div>
<p>where NFACE is the total number of faces. Since the METIS library is free to produce less partitions
than requested, NPART is not necessarily the final number of patches.</p>
<p>The METIS library must ensure that the constraints on the objective function are satisfied (see
<a class="reference internal" href="metis.html#partitioning-objective"><span class="std std-ref">partitioning objective</span></a>), and can thus
produce a drastically different number of partitions than requested. In particular, when
<a class="reference internal" href="metis.html#metis-face-weight"><span class="std std-ref">METIS_FACE_WEIGHT</span></a> is enabled for an enclosure
with faces of vastly different sizes, the requirement to evenly divide the total enclosure surface
area among the patches might produce significantly fewer partitions than requested.</p>
<p>Moreover, after the METIS library partitions the dual graph the patch splitting step breaks up
disconnected patches which may increase the final patch count. In short, NPART is only a suggestion
for the final patch count. Consider tweaking other parameters if an exact patch count is desired.</p>
</section>
<section id="metis-edge-weight">
<h4>METIS_EDGE_WEIGHT<a class="headerlink" href="#metis-edge-weight" title="Permalink to this headline"></a></h4>
<p>Determines whether to weight the edges of the dual graph by the corresponding enclosure edge lengths.</p>
<blockquote class="nml-param">
<div><p><strong>Type:</strong> <code class="docutils literal notranslate"><span class="pre">LOGICAL</span></code></p>
<p><strong>Domain:</strong> Must be <code class="docutils literal notranslate"><span class="pre">.true.</span></code> or <code class="docutils literal notranslate"><span class="pre">.false.</span></code></p>
<p><strong>Default:</strong> metis_edge_weight = <code class="docutils literal notranslate"><span class="pre">.true.</span></code></p>
</div></blockquote>
<p>This parameter determines whether the Euclidean length of the enclosure edges are assigned as edge
weights in the dual graph passed to the METIS library. If the parameter is false, then the dual
graph edges are assigned a weight of 1.</p>
<p>Refer to the <a class="reference internal" href="metis.html#edge-weight"><span class="std std-ref">edge weight section</span></a> of the METIS
algorithm documentation for more information on how the parameter affects the final patch
configuration.</p>
</section>
<section id="metis-face-weight">
<h4>METIS_FACE_WEIGHT<a class="headerlink" href="#metis-face-weight" title="Permalink to this headline"></a></h4>
<p>Determines whether to weight the vertices of the dual graph by the corresponding enclosure face
areas.</p>
<blockquote class="nml-param">
<div><p><strong>Type:</strong> <code class="docutils literal notranslate"><span class="pre">LOGICAL</span></code></p>
<p><strong>Domain:</strong> Must be <code class="docutils literal notranslate"><span class="pre">.true.</span></code> or <code class="docutils literal notranslate"><span class="pre">.false.</span></code></p>
<p><strong>Default:</strong> metis_face_weight = <code class="docutils literal notranslate"><span class="pre">.true.</span></code></p>
</div></blockquote>
<p>This parameter determines whether the area of the enclosure faces are assigned as vertex weights in
the dual graph passed to the METIS library. If the parameter is false, then the dual graph vertices
are assigned a weight of 1.</p>
<p>Refer to the <a class="reference internal" href="metis.html#face-weight"><span class="std std-ref">face weight section</span></a> of the METIS
algorithm documentation for more information on how the parameter affects the final patch
configuration.</p>
</section>
</section>
<section id="metis-library-parameters">
<h3>METIS library parameters<a class="headerlink" href="#metis-library-parameters" title="Permalink to this headline"></a></h3>
<p>The METIS graph partitioning routine admits the following integer-valued options that may be
specified, though all have reasonable defaults so that none must be specified. See the METIS
documentation <span id="id2">[<a class="reference internal" href="#id7" title="George Karypis and Vipin Kumar. A fast and high quality multilevel scheme for partitioning irregular graphs. SIAM J. Sci. Comput., 20(1):359–392, December 1998.">1</a>]</span> for more details on these options.</p>
<section id="metis-ptype">
<h4>METIS_PTYPE<a class="headerlink" href="#metis-ptype" title="Permalink to this headline"></a></h4>
<p>Specifies the partitioning method.</p>
<blockquote class="nml-param">
<div><p><strong>Type:</strong> <code class="docutils literal notranslate"><span class="pre">INTEGER</span></code></p>
<p><strong>Domain:</strong> metis_ptype <cite>in</cite> {0,1}</p>
<p><strong>Default:</strong> metis_ptype = 0</p>
</div></blockquote>
<p>The partitioning methods are encoded as follows:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 67%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>metis_ptype = 0</p></td>
<td><p>Multilevel recursive bisection</p></td>
</tr>
<tr class="row-odd"><td><p>metis_ptype = 1</p></td>
<td><p>Multilevel <cite>k</cite>-way partitioning</p></td>
</tr>
</tbody>
</table>
</section>
<section id="metis-objtype">
<h4>METIS_OBJTYPE<a class="headerlink" href="#metis-objtype" title="Permalink to this headline"></a></h4>
<p>Specifies the type of objective.</p>
<blockquote class="nml-param">
<div><p><strong>Type:</strong> <code class="docutils literal notranslate"><span class="pre">INTEGER</span></code></p>
<p><strong>Domain:</strong> metis_objtype <cite>in</cite> {0,1}</p>
<p><strong>Default:</strong> metis_objtype = 0</p>
</div></blockquote>
<p>The objective types are encoded as follows:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 67%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>metis_objtype = 0</p></td>
<td><p>Edge-cut minimization.</p></td>
</tr>
<tr class="row-odd"><td><p>metis_objtype = 1</p></td>
<td><p>Total communication volume minimization.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="metis-ctype">
<h4>METIS_CTYPE<a class="headerlink" href="#metis-ctype" title="Permalink to this headline"></a></h4>
<p>Specifies the matching scheme to be used during coarsening.</p>
<blockquote class="nml-param">
<div><p><strong>Type:</strong> <code class="docutils literal notranslate"><span class="pre">INTEGER</span></code></p>
<p><strong>Domain:</strong> metis_ctype <cite>in</cite> {0,1}</p>
<p><strong>Default:</strong> metis_ctype = 1</p>
</div></blockquote>
<p>The matching schemes are encoded as follows:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 67%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>metis_ctype = 0</p></td>
<td><p>Random matching</p></td>
</tr>
<tr class="row-odd"><td><p>metis_ctype = 1</p></td>
<td><p>Sorted heavy-edge matching</p></td>
</tr>
</tbody>
</table>
</section>
<section id="metis-iptype">
<h4>METIS_IPTYPE<a class="headerlink" href="#metis-iptype" title="Permalink to this headline"></a></h4>
<p>Specifies the algorithm used during initial partitioning (recursive bisection only).</p>
<blockquote class="nml-param">
<div><p><strong>Type:</strong> <code class="docutils literal notranslate"><span class="pre">INTEGER</span></code></p>
<p><strong>Domain:</strong> metis_iptype <cite>in</cite> {0,1,2,3}</p>
<p><strong>Default:</strong> metis_iptype = 0</p>
</div></blockquote>
<p>The partitioning algorithms are encoded as follows:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 67%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>metis_iptype = 0</p></td>
<td><p>Grows a bisection using a greedy strategy</p></td>
</tr>
<tr class="row-odd"><td><p>metis_iptype = 1</p></td>
<td><p>Computes a bisection at random followed by a refinement</p></td>
</tr>
<tr class="row-even"><td><p>metis_iptype = 2</p></td>
<td><p>Derives a separator from an edge cut.</p></td>
</tr>
<tr class="row-odd"><td><p>metis_iptype = 3</p></td>
<td><p>Grow a bisection using a greedy node-based strategy</p></td>
</tr>
</tbody>
</table>
</section>
<section id="metis-ncuts">
<h4>METIS_NCUTS<a class="headerlink" href="#metis-ncuts" title="Permalink to this headline"></a></h4>
<p>Specifies the number of different partitionings that will be computed. The final partitioning will
be the one that achieves the best edge-cut or communication volume.</p>
<blockquote class="nml-param">
<div><p><strong>Type:</strong> <code class="docutils literal notranslate"><span class="pre">INTEGER</span></code></p>
<p><strong>Domain:</strong> metis_ncuts &gt;= 1</p>
<p><strong>Default:</strong> metis_ncuts = 1</p>
</div></blockquote>
</section>
<section id="metis-niter">
<h4>METIS_NITER<a class="headerlink" href="#metis-niter" title="Permalink to this headline"></a></h4>
<p>Specifies the number of iterations of the refinement algorithm at each stage of the uncoarsening
process.</p>
<blockquote class="nml-param">
<div><p><strong>Type:</strong> <code class="docutils literal notranslate"><span class="pre">INTEGER</span></code></p>
<p><strong>Domain:</strong> metis_niter &gt;= 1</p>
<p><strong>Default:</strong> metis_niter = 10</p>
</div></blockquote>
</section>
<section id="metis-seed">
<h4>METIS_SEED<a class="headerlink" href="#metis-seed" title="Permalink to this headline"></a></h4>
<p>Specifies the seed for the random number generator.</p>
<blockquote class="nml-param">
<div><p><strong>Type:</strong> <code class="docutils literal notranslate"><span class="pre">INTEGER</span></code></p>
<p><strong>Domain:</strong> metis_seed <cite>in mathbb{Z}</cite></p>
<p><strong>Default:</strong> metis_seed = -1</p>
</div></blockquote>
</section>
<section id="metis-minconn">
<h4>METIS_MINCONN<a class="headerlink" href="#metis-minconn" title="Permalink to this headline"></a></h4>
<p>Specifies whether the partitioning procedure should seek to minimize the maximum degree of the
subdomain graph.</p>
<blockquote class="nml-param">
<div><p><strong>Type:</strong> <code class="docutils literal notranslate"><span class="pre">INTEGER</span></code></p>
<p><strong>Domain:</strong> metis_minconn <cite>in</cite> {0,1}</p>
<p><strong>Default:</strong> metis_minconn = 0</p>
</div></blockquote>
<p>The subdomain graph is the graph in which each partition is a node, and edges connect subdomains
with a shared interface. This parameter is encoded as follows:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 67%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>metis_minconn = 0</p></td>
<td><p>Does not explicitly minimize the maximum connectivity.</p></td>
</tr>
<tr class="row-odd"><td><p>metis_minconn = 1</p></td>
<td><p>Explicitly minimize the maximum connectivity.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="metis-no2hop">
<h4>METIS_NO2HOP<a class="headerlink" href="#metis-no2hop" title="Permalink to this headline"></a></h4>
<p>Specifies that the coarsening will not perform any 2–hop matchings when the standard matching
approach fails to sufficiently coarsen the graph.</p>
<blockquote class="nml-param">
<div><p><strong>Type:</strong> <code class="docutils literal notranslate"><span class="pre">INTEGER</span></code></p>
<p><strong>Domain:</strong> metis_no2hop <cite>in</cite> {0,1}</p>
<p><strong>Default:</strong> metis_no2hop = 1</p>
</div></blockquote>
<p>The 2–hop matching is very effective for graphs with power-law degree distributions. This parameter
is encoded as follows:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 67%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>metis_no2hop = 0</p></td>
<td><p>Performs a 2–hop matching.</p></td>
</tr>
<tr class="row-odd"><td><p>metis_no2hop = 1</p></td>
<td><p>Does not perform a 2–hop matching.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="metis-contig">
<h4>METIS_CONTIG<a class="headerlink" href="#metis-contig" title="Permalink to this headline"></a></h4>
<p>Specifies whether the partitioning procedure should produce partitions that are contiguous.</p>
<blockquote class="nml-param">
<div><p><strong>Type:</strong> <code class="docutils literal notranslate"><span class="pre">INTEGER</span></code></p>
<p><strong>Domain:</strong> metis_contig <cite>in</cite> {0,1}</p>
<p><strong>Default:</strong> metis_contig = 0</p>
</div></blockquote>
<p>If the dual graph of the mesh is not connected this option is ignored. This parameter is encoded as
follows:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 67%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>metis_contig = 0</p></td>
<td><p>Does not force contiguous partitions.</p></td>
</tr>
<tr class="row-odd"><td><p>metis_contig = 1</p></td>
<td><p>Forces contiguous partitions.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="metis-ufactor">
<h4>METIS_UFACTOR<a class="headerlink" href="#metis-ufactor" title="Permalink to this headline"></a></h4>
<p>Specifies the maximum allowed load imbalance among the partitions.</p>
<blockquote class="nml-param">
<div><p><strong>Type:</strong> <code class="docutils literal notranslate"><span class="pre">INTEGER</span></code></p>
<p><strong>Domain:</strong> metis_ufactor &gt;= 1</p>
<p><strong>Default:</strong> metis_ufactor = 1</p>
</div></blockquote>
<p>A value of <cite>n</cite> indicates that the allowed load imbalance is <cite>(1+n)/1000</cite>. The default is <cite>1</cite> for
recursive bisection (i.e., an imbalance of <cite>1.001</cite>) and the default value is <cite>30</cite> for <cite>k</cite>-way
partitioning (i.e., an imbalance of <cite>1.03</cite>).</p>
</section>
<section id="metis-dbglvl">
<h4>METIS_DBGLVL<a class="headerlink" href="#metis-dbglvl" title="Permalink to this headline"></a></h4>
<p>Specifies the amount and type of diagnostic information that will be written to <strong>stderr</strong> by the
partitioning procedure.</p>
<blockquote class="nml-param">
<div><p><strong>Type:</strong> <code class="docutils literal notranslate"><span class="pre">INTEGER</span></code></p>
<p><strong>Domain:</strong> metis_dbglvl &gt;= 1</p>
<p><strong>Default:</strong> metis_dbglvl = 0</p>
</div></blockquote>
<p>The default <cite>0</cite> means no output. Use <cite>1</cite> to write some basic information. Refer to the METIS
documentation <span id="id3">[<a class="reference internal" href="#id7" title="George Karypis and Vipin Kumar. A fast and high quality multilevel scheme for partitioning irregular graphs. SIAM J. Sci. Comput., 20(1):359–392, December 1998.">1</a>]</span> for the many other possible values and the
output they generate.</p>
</section>
</section>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline"></a></h2>
<p id="id4"><dl class="citation">
<dt class="label" id="id7"><span class="brackets">1</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id2">2</a>,<a href="#id3">3</a>)</span></dt>
<dd><p>George Karypis and Vipin Kumar. A fast and high quality multilevel scheme for partitioning irregular graphs. <em>SIAM J. Sci. Comput.</em>, 20(1):359–392, December 1998.</p>
</dd>
</dl>
</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="vac.html" class="btn btn-neutral float-left" title="Vertex Anchor Cluster (VAC)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../../../style_guide.html" class="btn btn-neutral float-right" title="Sphinx Documentation Style Guide" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Los Alamos National Laboratory.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>